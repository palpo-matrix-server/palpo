use std::sync::OnceLock;
use std::{
    collections::BTreeMap,
    convert::{TryFrom, TryInto},
    sync::Arc,
    time::Instant,
};

use clap::Parser;
use diesel::prelude::*;
use palpo_core::UnixMillis;
use regex::Regex;
use serde_json::value::to_raw_value;
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use tokio::sync::RwLock;

use super::event::PduBuilder;
use crate::core::appservice::Registration;
use crate::core::events::room::{
    canonical_alias::RoomCanonicalAliasEventContent,
    create::RoomCreateEventContent,
    guest_access::{GuestAccess, RoomGuestAccessEventContent},
    history_visibility::{HistoryVisibility, RoomHistoryVisibilityEventContent},
    join_rules::{JoinRule, RoomJoinRulesEventContent},
    member::{MembershipState, RoomMemberEventContent},
    message::RoomMessageEventContent,
    name::RoomNameEventContent,
    power_levels::RoomPowerLevelsEventContent,
    topic::RoomTopicEventContent,
};
use crate::core::events::TimelineEventType;
use crate::core::identifiers::*;
use crate::core::ServerName;
use crate::schema::*;
use crate::utils::{self, HtmlEscape};
use crate::{db, AppError, AppResult, PduEvent, AUTO_GEN_PASSWORD_LENGTH};

#[cfg_attr(test, derive(Debug))]
#[derive(Parser)]
#[command(name = "@palpo:server.name:", version = env!("CARGO_PKG_VERSION"))]
enum AdminCommand {
    #[command(verbatim_doc_comment)]
    /// Register an appservice using its registration YAML
    ///
    /// This command needs a YAML generated by an appservice (such as a bridge),
    /// which must be provided in a Markdown code-block below the command.
    ///
    /// Registering a new bridge using the ID of an existing bridge will replace
    /// the old one.
    ///
    /// [commandbody]
    // #``
    /// # yaml content here
    // #``
    RegisterAppservice,

    /// Unregister an appservice using its ID
    ///
    /// You can find the ID using the `list-appservices` command.
    UnregisterAppservice {
        /// The appservice to unregister
        appservice_identifier: String,
    },

    /// List all the currently registered appservices
    ListAppservices,

    /// List all rooms the server knows about
    ListRooms,

    /// List users in the database
    ListLocalUsers,

    /// List all rooms we are currently handling an incoming pdu from
    IncomingFederation,

    /// Deactivate a user
    ///
    /// User will not be removed from all rooms by default.
    /// Use --leave-rooms to force the user to leave all rooms
    DeactivateUser {
        #[arg(short, long)]
        leave_rooms: bool,
        user_id: Box<UserId>,
    },

    #[command(verbatim_doc_comment)]
    /// Deactivate a list of users
    ///
    /// Recommended to use in conjunction with list-local-users.
    ///
    /// Users will not be removed from joined rooms by default.
    /// Can be overridden with --leave-rooms flag.
    /// Removing a mass amount of users from a room may cause a significant amount of leave events.
    /// The time to leave rooms may depend significantly on joined rooms and servers.
    ///
    /// [commandbody]
    // #``
    /// # User list here
    // #``
    DeactivateAll {
        #[arg(short, long)]
        /// Remove users from their joined rooms
        leave_rooms: bool,
        #[arg(short, long)]
        /// Also deactivate admin accounts
        force: bool,
    },

    /// Get the auth_chain of a PDU
    GetAuthChain {
        /// An event ID (the $ character followed by the base64 reference hash)
        event_id: Box<EventId>,
    },

    #[command(verbatim_doc_comment)]
    /// Parse and print a PDU from a JSON
    ///
    /// The PDU event is only checked for validity and is not added to the
    /// database.
    ///
    /// [commandbody]
    // #``
    /// # PDU json content here
    // #``
    ParsePdu,

    /// Retrieve and print a PDU by ID from the Palpo database
    GetPdu {
        /// An event ID (a $ followed by the base64 reference hash)
        event_id: Box<EventId>,
    },

    /// Show configuration values
    ShowConfig,

    /// Reset user password
    ResetPassword {
        /// Username of the user for whom the password should be reset
        username: String,
    },

    /// Create a new user
    CreateUser {
        /// Username of the new user
        username: String,
        /// Password of the new user, if unspecified one is generated
        password: Option<String>,
    },

    /// Disables incoming federation handling for a room.
    DisableRoom { room_id: Box<RoomId> },
    /// Enables incoming federation handling for a room again.
    EnableRoom { room_id: Box<RoomId> },

    /// Verify json signatures
    /// [commandbody]
    // #``
    /// # json here
    // #``
    SignJson,

    /// Verify json signatures
    /// [commandbody]
    // #``
    /// # json here
    // #``
    VerifyJson,
}

#[derive(Debug)]
pub enum AdminRoomEvent {
    ProcessMessage(String),
    SendMessage(RoomMessageEventContent),
}

static SENDER: OnceLock<UnboundedSender<AdminRoomEvent>> = OnceLock::new();
pub fn supervise() {
    let (sender, receiver) = mpsc::unbounded_channel();
    SENDER.set(sender);
    tokio::spawn(async move {
        handle(receiver).await;
    });
}
fn sender() -> &'static mpsc::UnboundedSender<AdminRoomEvent> {
    SENDER.get().expect("sender is set")
}
async fn handle(mut receiver: UnboundedReceiver<AdminRoomEvent>) {
    // TODO: Use futures when we have long admin commands
    //let mut futures = FuturesUnordered::new();
    let conf = crate::config();

    let palpo_user = UserId::parse(format!("@palpo:{}", &conf.server_name)).expect("@palpo:server_name is valid");

    let palpo_room = crate::room::resolve_local_alias(
        format!("#admins:{}", &conf.server_name)
            .as_str()
            .try_into()
            .expect("#admins:server_name is a valid room alias"),
    );
    let palpo_room = if let Ok(Some(palpo_room)) = palpo_room {
        palpo_room
    } else {
        create_admin_room(&palpo_user).expect("admin room creation error")
    };

    loop {
        tokio::select! {
            Some(event) = receiver.recv() => {
                let message_content = match event {
                    AdminRoomEvent::SendMessage(content) => content,
                    AdminRoomEvent::ProcessMessage(room_message) => process_admin_message(room_message).await
                };

                 crate::room::timeline::build_and_append_pdu(
                    PduBuilder {
                        event_type: TimelineEventType::RoomMessage,
                        content: to_raw_value(&message_content).expect("event is valid, we just created it"),
                        unsigned: None,
                        state_key: None,
                        redacts: None,
                    },
                    &palpo_user,
                    &palpo_room,
                )
                .unwrap();
            }
        }
    }
}

pub fn process_message(room_message: String) {
    sender().send(AdminRoomEvent::ProcessMessage(room_message)).unwrap();
}

pub fn send_message(message_content: RoomMessageEventContent) {
    sender().send(AdminRoomEvent::SendMessage(message_content)).unwrap();
}

// Parse and process a message from the admin room
async fn process_admin_message(room_message: String) -> RoomMessageEventContent {
    let mut lines = room_message.lines().filter(|l| !l.trim().is_empty());
    let command_line = lines.next().expect("each string has at least one line");
    let body: Vec<_> = lines.collect();
    let conf = crate::config();

    let admin_command = match parse_admin_command(command_line) {
        Ok(command) => command,
        Err(error) => {
            let server_name = &conf.server_name;
            let message = error.replace("server.name", server_name.as_str());
            let html_message = usage_to_html(&message, server_name);

            return RoomMessageEventContent::text_html(message, html_message);
        }
    };

    match process_admin_command(admin_command, body).await {
        Ok(reply_message) => reply_message,
        Err(error) => {
            let markdown_message = format!(
                "Encountered an error while handling the command:\n\
                    ```\n{error}\n```",
            );
            let html_message = format!(
                "Encountered an error while handling the command:\n\
                    <pre>\n{error}\n</pre>",
            );

            RoomMessageEventContent::text_html(markdown_message, html_message)
        }
    }
}

// Parse chat messages from the admin room into an AdminCommand object
fn parse_admin_command(command_line: &str) -> std::result::Result<AdminCommand, String> {
    // Note: argv[0] is `@palpo:servername:`, which is treated as the main command
    let mut argv: Vec<_> = command_line.split_whitespace().collect();

    // Replace `help command` with `command --help`
    // Clap has a help subcommand, but it omits the long help description.
    if argv.len() > 1 && argv[1] == "help" {
        argv.remove(1);
        argv.push("--help");
    }

    // Backwards compatibility with `register_appservice`-style commands
    let command_with_dashes;
    if argv.len() > 1 && argv[1].contains('_') {
        command_with_dashes = argv[1].replace('_', "-");
        argv[1] = &command_with_dashes;
    }

    AdminCommand::try_parse_from(argv).map_err(|error| error.to_string())
}

async fn process_admin_command(command: AdminCommand, body: Vec<&str>) -> AppResult<RoomMessageEventContent> {
    let conf = crate::config();
    let reply_message_content = match command {
        AdminCommand::RegisterAppservice => {
            if body.len() > 2 && body[0].trim() == "```" && body.last().unwrap().trim() == "```" {
                let appservice_config = body[1..body.len() - 1].join("\n");
                let parsed_config = serde_yaml::from_str::<Registration>(&appservice_config);
                match parsed_config {
                    Ok(yaml) => match crate::appservice::register_appservice(yaml) {
                        Ok(id) => RoomMessageEventContent::text_plain(format!("Appservice registered with ID: {id}.")),
                        Err(e) => RoomMessageEventContent::text_plain(format!("Failed to register appservice: {e}")),
                    },
                    Err(e) => RoomMessageEventContent::text_plain(format!("Could not parse appservice config: {e}")),
                }
            } else {
                RoomMessageEventContent::text_plain("Expected code block in command body. Add --help for details.")
            }
        }
        AdminCommand::UnregisterAppservice { appservice_identifier } => {
            match crate::appservice::unregister_appservice(&appservice_identifier) {
                Ok(()) => RoomMessageEventContent::text_plain("Appservice unregistered."),
                Err(e) => RoomMessageEventContent::text_plain(format!("Failed to unregister appservice: {e}")),
            }
        }
        AdminCommand::ListAppservices => {
            if let Ok(appservices) = crate::appservice::all() {
                let count = appservices.len();
                let output = format!(
                    "Appservices ({}): {}",
                    count,
                    appservices.keys().map(|s| &**s).collect::<Vec<_>>().join(", ")
                );
                RoomMessageEventContent::text_plain(output)
            } else {
                RoomMessageEventContent::text_plain("Failed to get appservices.")
            }
        }
        AdminCommand::ListRooms => {
            let room_ids = rooms::table
                .order_by(rooms::id.desc())
                .select(rooms::id)
                .load::<OwnedRoomId>(&mut *db::connect()?)?;
            let mut items = Vec::with_capacity(room_ids.len());
            for room_id in room_ids {
                let members = crate::room::joined_member_count(&room_id)?;
                items.push(format!("members: {} \t\tin room: {}", members, room_id));
            }
            let output = format!("Rooms:\n{}", items.join("\n"));
            RoomMessageEventContent::text_plain(output)
        }
        AdminCommand::ListLocalUsers => match crate::user::list_local_users() {
            Ok(users) => {
                let mut msg: String = format!("Found {} local user account(s):\n", users.len());
                msg += &users.into_iter().map(|u| u.to_string()).collect::<Vec<_>>().join("\n");
                RoomMessageEventContent::text_plain(&msg)
            }
            Err(e) => RoomMessageEventContent::text_plain(e.to_string()),
        },
        AdminCommand::IncomingFederation => {
            let map = crate::ROOM_ID_FEDERATION_HANDLE_TIME.read().unwrap();
            let mut msg: String = format!("Handling {} incoming pdus:\n", map.len());

            for (r, (e, i)) in map.iter() {
                let elapsed = i.elapsed();
                msg += &format!("{} {}: {}m{}s\n", r, e, elapsed.as_secs() / 60, elapsed.as_secs() % 60);
            }
            RoomMessageEventContent::text_plain(&msg)
        }
        AdminCommand::GetAuthChain { event_id } => {
            let event_id = Arc::<EventId>::from(event_id);
            if let Some(event) = crate::room::timeline::get_pdu_json(&event_id)? {
                let room_id_str = event
                    .get("room_id")
                    .and_then(|val| val.as_str())
                    .ok_or_else(|| AppError::internal("Invalid event in database"))?;

                let room_id = <&RoomId>::try_from(room_id_str)
                    .map_err(|_| AppError::internal("Invalid room id field in event in database"))?;
                let start = Instant::now();
                let count = crate::room::auth_chain::get_auth_chain(room_id, &event_id)?.len();
                let elapsed = start.elapsed();
                RoomMessageEventContent::text_plain(format!("Loaded auth chain with length {count} in {elapsed:?}"))
            } else {
                RoomMessageEventContent::text_plain("Event not found.")
            }
        }
        AdminCommand::ParsePdu => {
            if body.len() > 2 && body[0].trim() == "```" && body.last().unwrap().trim() == "```" {
                let string = body[1..body.len() - 1].join("\n");
                match serde_json::from_str(&string) {
                    Ok(value) => match crate::core::signatures::reference_hash(&value, &RoomVersionId::V6) {
                        Ok(hash) => {
                            let event_id = EventId::parse(format!("${hash}"));

                            match serde_json::from_value::<PduEvent>(
                                serde_json::to_value(value).expect("value is json"),
                            ) {
                                Ok(pdu) => {
                                    RoomMessageEventContent::text_plain(format!("EventId: {event_id:?}\n{pdu:#?}"))
                                }
                                Err(e) => RoomMessageEventContent::text_plain(format!(
                                    "EventId: {event_id:?}\nCould not parse event: {e}"
                                )),
                            }
                        }
                        Err(e) => RoomMessageEventContent::text_plain(format!("Could not parse PDU JSON: {e:?}")),
                    },
                    Err(e) => RoomMessageEventContent::text_plain(format!("Invalid json in command body: {e}")),
                }
            } else {
                RoomMessageEventContent::text_plain("Expected code block in command body.")
            }
        }
        AdminCommand::GetPdu { event_id } => {
            let mut outlier = false;
            let mut pdu_json = crate::room::timeline::get_pdu_json(&event_id)?;
            if pdu_json.is_none() {
                outlier = true;
                pdu_json = crate::room::timeline::get_pdu_json(&event_id)?;
            }
            match pdu_json {
                Some(json) => {
                    let json_text = serde_json::to_string_pretty(&json).expect("canonical json is valid json");
                    RoomMessageEventContent::text_html(
                        format!(
                            "{}\n```json\n{}\n```",
                            if outlier { "PDU is outlier" } else { "PDU was accepted" },
                            json_text
                        ),
                        format!(
                            "<p>{}</p>\n<pre><code class=\"language-json\">{}\n</code></pre>\n",
                            if outlier { "PDU is outlier" } else { "PDU was accepted" },
                            HtmlEscape(&json_text)
                        ),
                    )
                }
                None => RoomMessageEventContent::text_plain("PDU not found."),
            }
        }
        AdminCommand::ShowConfig => {
            // Construct and send the response
            RoomMessageEventContent::text_plain(format!("{}", conf))
        }
        AdminCommand::ResetPassword { username } => {
            let user_id = match UserId::parse_with_server_name(username.as_str().to_lowercase(), &conf.server_name) {
                Ok(id) => id,
                Err(e) => {
                    return Ok(RoomMessageEventContent::text_plain(format!(
                        "The supplied username is not a valid username: {e}"
                    )))
                }
            };

            // Check if the specified user is valid
            if !crate::user::user_exists(&user_id)?
                || user_id == UserId::parse_with_server_name("palpo", &conf.server_name).expect("palpo user exists")
            {
                return Ok(RoomMessageEventContent::text_plain(
                    "The specified user does not exist!",
                ));
            }

            let new_password = utils::random_string(AUTO_GEN_PASSWORD_LENGTH);

            match crate::user::set_password(&user_id, &new_password) {
                Ok(()) => RoomMessageEventContent::text_plain(format!(
                    "Successfully reset the password for user {user_id}: {new_password}"
                )),
                Err(e) => {
                    RoomMessageEventContent::text_plain(format!("Couldn't reset the password for user {user_id}: {e}"))
                }
            }
        }
        AdminCommand::CreateUser { username, password } => {
            let password = password.unwrap_or_else(|| utils::random_string(AUTO_GEN_PASSWORD_LENGTH));
            // Validate user id
            let user_id = match UserId::parse_with_server_name(username.as_str().to_lowercase(), &conf.server_name) {
                Ok(id) => id,
                Err(e) => {
                    return Ok(RoomMessageEventContent::text_plain(format!(
                        "The supplied username is not a valid username: {e}"
                    )))
                }
            };
            if user_id.is_historical() {
                return Ok(RoomMessageEventContent::text_plain(format!(
                    "Userid {user_id} is not allowed due to historical"
                )));
            }
            if crate::user::user_exists(&user_id)? {
                return Ok(RoomMessageEventContent::text_plain(format!(
                    "Userid {user_id} already exists"
                )));
            }
            // Create user
            crate::user::create_user(&user_id, Some(password.as_str()))?;

            // Default to pretty display_name
            let mut display_name = user_id.localpart().to_owned();

            // If enabled append lightning bolt to display name (default true)
            if conf.enable_lightning_bolt {
                display_name.push_str(" ⚡️");
            }

            crate::user::set_display_name(&user_id, Some(&*display_name))?;

            // Initial account data
            crate::user::set_data(
                &user_id,
                None,
                &crate::core::events::GlobalAccountDataEventType::PushRules.to_string(),
                serde_json::to_value(crate::core::events::push_rules::PushRulesEvent {
                    content: crate::core::events::push_rules::PushRulesEventContent {
                        global: crate::core::push::Ruleset::server_default(&user_id),
                    },
                })
                .expect("to json value always works"),
            )?;

            // we dont add a device since we're not the user, just the creator

            // Inhibit login does not work for guests
            RoomMessageEventContent::text_plain(format!(
                "Created user with user_id: {user_id} and password: {password}"
            ))
        }
        AdminCommand::DisableRoom { room_id } => {
            crate::room::disable_room(&room_id, true)?;
            RoomMessageEventContent::text_plain("Room disabled.")
        }
        AdminCommand::EnableRoom { room_id } => {
            crate::room::disable_room(&room_id, false)?;
            RoomMessageEventContent::text_plain("Room enabled.")
        }
        AdminCommand::DeactivateUser { leave_rooms, user_id } => {
            let user_id = Arc::<UserId>::from(user_id);
            if crate::user::user_exists(&user_id)? {
                RoomMessageEventContent::text_plain(format!("Making {user_id} leave all rooms before deactivation..."));

                crate::user::deactivate(&user_id, &user_id)?;

                if leave_rooms {
                    crate::membership::leave_all_rooms(&user_id)?;
                }

                RoomMessageEventContent::text_plain(format!("User {user_id} has been deactivated"))
            } else {
                RoomMessageEventContent::text_plain(format!("User {user_id} doesn't exist on this server"))
            }
        }
        AdminCommand::DeactivateAll { leave_rooms, force } => {
            if body.len() > 2 && body[0].trim() == "```" && body.last().unwrap().trim() == "```" {
                let usernames = body.clone().drain(1..body.len() - 1).collect::<Vec<_>>();

                let mut user_ids: Vec<OwnedUserId> = Vec::new();

                for &username in &usernames {
                    match <&UserId>::try_from(username) {
                        Ok(user_id) => user_ids.push(user_id.to_owned()),
                        Err(_) => {
                            return Ok(RoomMessageEventContent::text_plain(format!(
                                "{username} is not a valid username"
                            )))
                        }
                    }
                }

                let mut deactivation_count = 0;
                let mut admins = Vec::new();

                if !force {
                    user_ids = users::table
                        .filter(users::id.eq_any(user_ids))
                        .filter(users::is_admin.eq(false))
                        .select(users::id)
                        .load::<OwnedUserId>(&mut *db::connect()?)?;
                    admins = users::table
                        .filter(users::id.eq_any(&user_ids))
                        .filter(users::is_admin.eq(false))
                        .select(users::id)
                        .load::<String>(&mut *db::connect()?)?;
                }

                for user_id in &user_ids {
                    if crate::user::deactivate(user_id, user_id).is_ok() {
                        deactivation_count += 1
                    }
                }

                if leave_rooms {
                    for user_id in &user_ids {
                        crate::membership::leave_all_rooms(user_id).ok();
                    }
                }

                if admins.is_empty() {
                    RoomMessageEventContent::text_plain(format!("Deactivated {deactivation_count} accounts."))
                } else {
                    RoomMessageEventContent::text_plain(format!(
                        "Deactivated {} accounts.\nSkipped admin accounts: {:?}. Use --force to deactivate admin accounts",
                        deactivation_count,
                        admins.join(", ")
                    ))
                }
            } else {
                RoomMessageEventContent::text_plain("Expected code block in command body. Add --help for details.")
            }
        }
        AdminCommand::SignJson => {
            if body.len() > 2 && body[0].trim() == "```" && body.last().unwrap().trim() == "```" {
                let string = body[1..body.len() - 1].join("\n");
                match serde_json::from_str(&string) {
                    Ok(mut value) => {
                        crate::core::signatures::sign_json(conf.server_name.as_str(), crate::keypair(), &mut value)
                            .expect("our request json is what palpo expects");
                        let json_text = serde_json::to_string_pretty(&value).expect("canonical json is valid json");
                        RoomMessageEventContent::text_plain(json_text)
                    }
                    Err(e) => RoomMessageEventContent::text_plain(format!("Invalid json: {e}")),
                }
            } else {
                RoomMessageEventContent::text_plain("Expected code block in command body. Add --help for details.")
            }
        }
        AdminCommand::VerifyJson => {
            if body.len() > 2 && body[0].trim() == "```" && body.last().unwrap().trim() == "```" {
                let string = body[1..body.len() - 1].join("\n");
                match serde_json::from_str(&string) {
                    Ok(value) => {
                        let pub_key_map = RwLock::new(BTreeMap::new());

                        // Generally we shouldn't be checking against expired keys unless required, so in the admin
                        // room it might be best to not allow expired keys
                        crate::event::handler::fetch_required_signing_keys(&value, &pub_key_map).await?;

                        let mut expired_key_map = BTreeMap::new();
                        let mut valid_key_map = BTreeMap::new();

                        for (server, keys) in pub_key_map.into_inner().into_iter() {
                            if keys.valid_until_ts > UnixMillis::now() {
                                valid_key_map.insert(
                                    server,
                                    keys.verify_keys.into_iter().map(|(id, key)| (id, key.key)).collect(),
                                );
                            } else {
                                expired_key_map.insert(
                                    server,
                                    keys.verify_keys.into_iter().map(|(id, key)| (id, key.key)).collect(),
                                );
                            }
                        }
                        if crate::core::signatures::verify_json(&valid_key_map, &value).is_ok() {
                            RoomMessageEventContent::text_plain("Signature correct")
                        } else if let Err(e) = crate::core::signatures::verify_json(&expired_key_map, &value) {
                            RoomMessageEventContent::text_plain(format!("Signature verification failed: {e}"))
                        } else {
                            RoomMessageEventContent::text_plain("Signature correct (with expired keys)")
                        }
                    }
                    Err(e) => RoomMessageEventContent::text_plain(format!("Invalid json: {e}")),
                }
            } else {
                RoomMessageEventContent::text_plain("Expected code block in command body. Add --help for details.")
            }
        }
    };

    Ok(reply_message_content)
}

// Utility to turn clap's `--help` text to HTML.
fn usage_to_html(text: &str, server_name: &ServerName) -> String {
    // Replace `@palpo:servername:-subcmdname` with `@palpo:servername: subcmdname`
    let text = text.replace(&format!("@palpo:{server_name}:-"), &format!("@palpo:{server_name}: "));

    // For the palpo admin room, subcommands become main commands
    let text = text.replace("SUBCOMMAND", "COMMAND");
    let text = text.replace("subcommand", "command");

    // Escape option names (e.g. `<element-id>`) since they look like HTML tags
    let text = text.replace('<', "&lt;").replace('>', "&gt;");

    // Italicize the first line (command name and version text)
    let re = Regex::new("^(.*?)\n").expect("Regex compilation should not fail");
    let text = re.replace_all(&text, "<em>$1</em>\n");

    // Unmerge wrapped lines
    let text = text.replace("\n            ", "  ");

    // Wrap option names in backticks. The lines look like:
    //     -V, --version  Prints version information
    // And are converted to:
    // <code>-V, --version</code>: Prints version information
    // (?m) enables multi-line mode for ^ and $
    let re = Regex::new("(?m)^    (([a-zA-Z_&;-]+(, )?)+)  +(.*)$").expect("Regex compilation should not fail");
    let text = re.replace_all(&text, "<code>$1</code>: $4");

    // Look for a `[commandbody]` tag. If it exists, use all lines below it that
    // start with a `#` in the USAGE section.
    let mut text_lines: Vec<&str> = text.lines().collect();
    let mut command_body = String::new();

    if let Some(line_index) = text_lines.iter().position(|line| *line == "[commandbody]") {
        text_lines.remove(line_index);

        while text_lines
            .get(line_index)
            .map(|line| line.starts_with('#'))
            .unwrap_or(false)
        {
            command_body += if text_lines[line_index].starts_with("# ") {
                &text_lines[line_index][2..]
            } else {
                &text_lines[line_index][1..]
            };
            command_body += "[nobr]\n";
            text_lines.remove(line_index);
        }
    }

    let text = text_lines.join("\n");

    // Improve the usage section
    let text = if command_body.is_empty() {
        // Wrap the usage line in code tags
        let re = Regex::new("(?m)^USAGE:\n    (@palpo:.*)$").expect("Regex compilation should not fail");
        re.replace_all(&text, "USAGE:\n<code>$1</code>").to_string()
    } else {
        // Wrap the usage line in a code block, and add a yaml block example
        // This makes the usage of e.g. `register-appservice` more accurate
        let re = Regex::new("(?m)^USAGE:\n    (.*?)\n\n").expect("Regex compilation should not fail");
        re.replace_all(&text, "USAGE:\n<pre>$1[nobr]\n[commandbodyblock]</pre>")
            .replace("[commandbodyblock]", &command_body)
    };

    // Add HTML line-breaks

    text.replace("\n\n\n", "\n\n")
        .replace('\n', "<br>\n")
        .replace("[nobr]<br>", "")
}

/// Gets the room ID of the admin room
///
/// Errors are propagated from the database, and will have None if there is no admin room
pub(crate) fn get_admin_room() -> AppResult<Option<OwnedRoomId>> {
    let conf = crate::config();
    let admin_room_alias: Box<RoomAliasId> = format!("#admins:{}", &conf.server_name)
        .try_into()
        .expect("#admins:server_name is a valid alias name");
    crate::room::resolve_local_alias(&admin_room_alias)
}

/// Create the admin room.
///
/// Users in this room are considered admins by palpo, and the room can be
/// used to issue admin commands by talking to the server user inside it.
pub(crate) fn create_admin_room(created_by: &UserId) -> AppResult<OwnedRoomId> {
    let conf = crate::config();
    let room_id = RoomId::new(&conf.server_name);

    crate::room::ensure_room(&room_id, created_by)?;

    // Create a user for the server
    let palpo_user = UserId::parse_with_server_name("palpo", &conf.server_name).expect("@palpo:server_name is valid");

    if let Err(e) = crate::user::create_user(&palpo_user, None) {
        tracing::error!(error = ?e, "create palpo admin user failed.");
    }

    let room_version = conf.room_version.clone();
    let mut content = match room_version {
        RoomVersionId::V1
        | RoomVersionId::V2
        | RoomVersionId::V3
        | RoomVersionId::V4
        | RoomVersionId::V5
        | RoomVersionId::V6
        | RoomVersionId::V7
        | RoomVersionId::V8
        | RoomVersionId::V9
        | RoomVersionId::V10 => RoomCreateEventContent::new_v1(palpo_user.to_owned()),
        RoomVersionId::V11 => RoomCreateEventContent::new_v11(),
        _ => unreachable!("Validity of room version already checked"),
    };
    content.federate = true;
    content.predecessor = None;
    content.room_version = room_version;

    // 1. The room create event
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomCreate,
            content: to_raw_value(&content).expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 2. Make palpo bot join
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomMember,
            content: to_raw_value(&RoomMemberEventContent {
                membership: MembershipState::Join,
                display_name: None,
                avatar_url: None,
                is_direct: None,
                third_party_invite: None,
                blurhash: None,
                reason: None,
                join_authorized_via_users_server: None,
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some(palpo_user.to_string()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 3. Power levels
    let mut users = BTreeMap::new();
    users.insert(palpo_user.clone(), 100.into());

    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomPowerLevels,
            content: to_raw_value(&RoomPowerLevelsEventContent {
                users,
                ..Default::default()
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 4.1 Join Rules
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomJoinRules,
            content: to_raw_value(&RoomJoinRulesEventContent::new(JoinRule::Invite))
                .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 4.2 History Visibility
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomHistoryVisibility,
            content: to_raw_value(&RoomHistoryVisibilityEventContent::new(HistoryVisibility::Shared))
                .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 4.3 Guest Access
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomGuestAccess,
            content: to_raw_value(&RoomGuestAccessEventContent::new(GuestAccess::Forbidden))
                .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 5. Events implied by name and topic
    let room_name = format!("{} Admin Room", &conf.server_name);
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomName,
            content: to_raw_value(&RoomNameEventContent::new(room_name)).expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomTopic,
            content: to_raw_value(&RoomTopicEventContent {
                topic: format!("Manage {}", &conf.server_name),
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // 6. Room alias
    let alias: OwnedRoomAliasId = format!("#admins:{}", &conf.server_name)
        .try_into()
        .expect("#admins:server_name is a valid alias name");

    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomCanonicalAlias,
            content: to_raw_value(&RoomCanonicalAliasEventContent {
                alias: Some(alias.clone()),
                alt_aliases: Vec::new(),
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    crate::room::set_alias(&room_id, alias, created_by)?;

    Ok(room_id.to_owned())
}

/// Invite the user to the palpo admin room.
///
/// In palpo, this is equivalent to granting admin privileges.
pub(crate) fn make_user_admin(user_id: &UserId, display_name: String) -> AppResult<()> {
    let conf = crate::config();

    let room_id = get_admin_room()?.expect("Admin room must exist");

    // Use the server user to grant the new admin's power level
    let palpo_user = UserId::parse_with_server_name("palpo", &conf.server_name).expect("@palpo:server_name is valid");

    // Invite and join the real user
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomMember,
            content: to_raw_value(&RoomMemberEventContent {
                membership: MembershipState::Invite,
                display_name: None,
                avatar_url: None,
                is_direct: None,
                third_party_invite: None,
                blurhash: None,
                reason: None,
                join_authorized_via_users_server: None,
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some(user_id.to_string()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;
    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomMember,
            content: to_raw_value(&RoomMemberEventContent {
                membership: MembershipState::Join,
                display_name: Some(display_name),
                avatar_url: None,
                is_direct: None,
                third_party_invite: None,
                blurhash: None,
                reason: None,
                join_authorized_via_users_server: None,
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some(user_id.to_string()),
            redacts: None,
        },
        user_id,
        &room_id,
    )?;

    // Set power level
    let mut users = BTreeMap::new();
    users.insert(palpo_user.to_owned(), 100.into());
    users.insert(user_id.to_owned(), 100.into());

    crate::room::timeline::build_and_append_pdu(
        PduBuilder {
            event_type: TimelineEventType::RoomPowerLevels,
            content: to_raw_value(&RoomPowerLevelsEventContent {
                users,
                ..Default::default()
            })
            .expect("event is valid, we just created it"),
            unsigned: None,
            state_key: Some("".to_owned()),
            redacts: None,
        },
        &palpo_user,
        &room_id,
    )?;

    // Send welcome message
    crate::room::timeline::build_and_append_pdu(
            PduBuilder {
                event_type: TimelineEventType::RoomMessage,
                content: to_raw_value(&RoomMessageEventContent::text_html(
                        format!("## Thank you for trying out Palpo!\n\nPalpo is currently in Beta. This means you can join and participate in most Matrix rooms, but not all features are supported and you might run into bugs from time to time.\n\nHelpful links:\n> Website: https://palpo.im\n> Git and Documentation: https://gitlab.com/famedly/palpo\n> Report issues: https://gitlab.com/famedly/palpo/-/issues\n\nFor a list of available commands, send the following message in this room: `@palpo:{}: --help`\n\nHere are some rooms you can join (by typing the command):\n\nPalpo room (Ask questions and get notified on updates):\n`/join #palpo:fachschaften.org`\n\nPalpo lounge (Off-topic, only Palpo users are allowed to join)\n`/join #palpo-lounge:palpo.im`", &conf.server_name),
                        format!("<h2>Thank you for trying out Palpo!</h2>\n<p>Palpo is currently in Beta. This means you can join and participate in most Matrix rooms, but not all features are supported and you might run into bugs from time to time.</p>\n<p>Helpful links:</p>\n<blockquote>\n<p>Website: https://palpo.im<br>Git and Documentation: https://gitlab.com/famedly/palpo<br>Report issues: https://gitlab.com/famedly/palpo/-/issues</p>\n</blockquote>\n<p>For a list of available commands, send the following message in this room: <code>@palpo:{}: --help</code></p>\n<p>Here are some rooms you can join (by typing the command):</p>\n<p>Palpo room (Ask questions and get notified on updates):<br><code>/join #palpo:fachschaften.org</code></p>\n<p>Palpo lounge (Off-topic, only Palpo users are allowed to join)<br><code>/join #palpo-lounge:palpo.im</code></p>\n", &conf.server_name),
                ))
                .expect("event is valid, we just created it"),
                unsigned: None,
                state_key: None,
                redacts: None,
            },
            &palpo_user,
            &room_id,
        )?;
    Ok(())
}
